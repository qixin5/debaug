package edu.gatech.cc.debaug;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import java.io.File;
import org.apache.commons.io.FileUtils;

public class GCovBasedCodeRemover
{
    /* codef is the source code to be shrinked.
       linef is a file generated by applying line-position printer to codef. 
       gcovf is a file generated by applying gcov (with -i option) on codef. */
    /*
      It doesn't seem to change line numbers. That is, if a line is chosen 
      not to be removed, its line number will not change. */
    public static void main(String[] args) {
	File codef = new File(args[0]);
	File linef = new File(args[1]);
	File gcovf = new File(args[2]);
	System.out.println(getRemovedString(codef, linef, gcovf));
    }

    public static String getRemovedString(File codef, File linef, File gcovf) {
	List<String> gcov_lines = null;
	try { gcov_lines = FileUtils.readLines(gcovf, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
	if (gcov_lines == null) { return null; }
	
	Map<Integer,Long> lcmap = GCovUtils.getLineCountMap(gcov_lines);
	Map<Integer,String> iflnmap = GCovUtils.getInconsistentFunctionLineNameMap(gcov_lines);
	return getRemovedString(codef, linef, lcmap, iflnmap);
    }


    public static String getRemovedString(File codef, File linef, String gcovstr) {
	List<String> gcov_lines = Arrays.asList(gcovstr.split("\n"));
	return getRemovedString(codef, linef, GCovUtils.getLineCountMap(gcov_lines), GCovUtils.getInconsistentFunctionLineNameMap(gcov_lines));
    }
    
    //    public static String getRemovedString(File codef, File linef, PathCoverage pcov) {
    //	return getRemovedString(codef, linef, pcov.getLineCountMap());
    //    }


    public static String getRemovedString(File codef, File linef, Map<Integer,Long> lcmap) {
	//No reverting for functions possibly with bad code tracking
	return getRemovedString(codef, linef, lcmap, new HashMap<Integer,String>());
    }

    
    public static String getRemovedString(File codef, File linef,
					  Map<Integer,Long> lcmap,
					  Map<Integer,String> iflnmap) {
	Map<Integer, Integer> ffs_map = LineFileParser.getStartEndLineMap(linef, "function");
	Map<Integer, Integer> sfs_map = LineFileParser.getStartEndLineMap(linef, "statement");
	Map<Integer, String> spfs_map = LineFileParser.getStartPropertyLineMap(linef, "statement"); //Starting line -> stmt type

	List<String> codef_lines = null;
	try { codef_lines = FileUtils.readLines(codef, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
	if (codef_lines == null) { return null; }
	int codef_lines_size = codef_lines.size();
	List<String> rslt_lines = new ArrayList<String>(codef_lines_size+1);


	//Either adding the original line or an empty line
	//For label stmt line, insert ";" at the end (compiling error otherwise)
	for (int i=1; i<=codef_lines_size; i++) {

	    if (lcmap.get(i) != null && lcmap.get(i).longValue() == 0l) { //Non-covered

		if (ffs_map.get(i) != null) { //Is a function
		    int end = ffs_map.get(i).intValue(); //function-body end line
		    boolean full_removal = true;
		    for (int k=i; k<=end; k++) {
			if (lcmap.get(k) != null && lcmap.get(k) > 0l) {
			    full_removal = false;
			    break;
			}
		    }
		    if (!full_removal) {
			rslt_lines.add(codef_lines.get(i-1));
			continue;
		    }

		    //For full removal
		    int start = -1; //function-body start line
		    for (int k=i; k<=end; k++) { //Looking for the function-body start line
			if (codef_lines.get(k-1).contains("{")) {
			    start = k;
			    break;
			}
		    }
		    
		    if (start != -1) {
			for (int k=i; k<start; k++) { //Add lines up to the function-body line
			    rslt_lines.add(codef_lines.get(k-1));
			}

			//For start line, add content up to "{"
			String start_line = codef_lines.get(start-1);
			rslt_lines.add(start_line.substring(0, start_line.indexOf("{")+1));

			//Add "" for function-body lines
			for (int k=start+1; k<end; k++) {
			    rslt_lines.add("");
			}

			//For end line, add content from "}" to line-end
			String end_line = codef_lines.get(end-1);
			rslt_lines.add(end_line.substring(end_line.indexOf("}")));

			//Reset i
			i = end;
		    }
		    else {
			//Wierd, no "{" found. Don't emptify the function body.
			rslt_lines.add(codef_lines.get(i-1));
		    }

		    continue;
		}

		//Don't remove compound line
		if ("compound".equals(spfs_map.get(i))) {
		    rslt_lines.add(codef_lines.get(i-1));
		    continue;
		}
		
		//Don't remove label line
		//(otherwise, we may have missing labels, see gcoverrorshooting-case0)
		//Need to however insert ";" at the end (compiling error otherwise)
		if ("label".equals(spfs_map.get(i))) {
		    rslt_lines.add(getSemiColonAugmentedLabelLine(codef_lines.get(i-1)));
		    continue;
		}

		//This line corresponds to ending line of function-def signature.
		//It's possible that function is not covered,
		//but its first line (of function-def signature)
		//is not marked by gcov (see gcoverrorshooting-case2).
		//(This is possible, as the function signature can span multiple lines.)
		//If so, we use fbcompound label to identify surrounding "{" and "}"
		//for function-body removal.
		if ("fbcompound".equals(spfs_map.get(i))) {
		    if (sfs_map.get(i) != null) {
			int j = sfs_map.get(i).intValue();
			boolean full_removal = true;
			for (int k=i; k<=j; k++) {
			    if (lcmap.get(k) != null && lcmap.get(k) > 0l) { //Inner stmt covered!
				full_removal = false;
				break;
			    }
			}
			if (!full_removal) {
			    rslt_lines.add(codef_lines.get(i-1));
			    continue;
			}

			//For full removal
			for (int k=i; k<=j; k++) {
			    if (k == i) { //Removed code from "{" to line-end
				String oldline = codef_lines.get(k-1);
				rslt_lines.add(oldline.substring(0, oldline.indexOf("{")+1));
			    } 
			    else if (k == j) { //Removed code up to "}"
				String oldline = codef_lines.get(k-1);
				rslt_lines.add(oldline.substring(oldline.indexOf("}")));
			    } 
			    else { //Removed line
				rslt_lines.add("");
			    }
			}
			i = j; //Move cursor to the end of the function
		    }
		    else {
			rslt_lines.add(codef_lines.get(i-1));
		    }
		    continue;
		}
		
		//For statement line
		if (sfs_map.get(i) != null) {
		    int j = sfs_map.get(i).intValue(); //Ending line
		    boolean full_removal = true;
		    for (int k=i; k<=j; k++) {
			if (lcmap.get(k) != null && lcmap.get(k) > 0l) { //Inner stmt covered!
			    full_removal = false;
			    break;
			}
		    }

		    if (full_removal) {
			for (int k=i; k<=j; k++) {
			    rslt_lines.add(""); //Remove the line
			}
			i = j; //Move cursor to the end of the stmt
		    }
		    else {
			//Do not remove the line
			rslt_lines.add(codef_lines.get(i-1));
		    }
		}

		else {
		    //Non-covered line not recorded in line file. Keep it.");
		    rslt_lines.add(codef_lines.get(i-1));
		}
	    }

	    else { //If code is covered, keep it.

		if ("label".equals(spfs_map.get(i))) {
		    //The reason why we add a ";" is because
		    //it is possible for llvm to flag a label line as COVERED
		    //but its labeled content as NON-COVERED. (Wierd, right?)
		    //In such case, compilation error can occur
		    //if removing the label content but keeping the label line.
		    rslt_lines.add(getSemiColonAugmentedLabelLine(codef_lines.get(i-1)));
		}
		else {
		    rslt_lines.add(codef_lines.get(i-1)); //Add the original line
		}
	    }
	}

	//Restore inconsistent functions as its original full version
	for (Integer sln_key : iflnmap.keySet()) {
	    int sln = sln_key.intValue();
	    //===============
	    //System.err.println("Starting line: " + sln);
	    //===============	    
	    int eln = -1;
	    if (ffs_map.get(sln) != null) {
		eln = ffs_map.get(sln).intValue();
	    }
	    else if (sfs_map.get(sln) != null && "fbcompound".equals(spfs_map.get(sln))) {
		eln = sfs_map.get(sln).intValue();
	    }
	    else {
		System.err.println("Cannot revert function back to its original version: " + iflnmap.get(sln_key));
		continue;
	    }
	    
	    for (int l=sln; l<=eln; l++) {
		rslt_lines.set(l-1, codef_lines.get(l-1));
	    }
	}
	
	StringBuilder sb = null;
	for (String rslt_line : rslt_lines) {
	    if (sb == null) { sb = new StringBuilder(); }
	    else { sb.append("\n"); }
	    sb.append(rslt_line);
	}

	if (sb != null) { return sb.toString(); }
	else { return null; }
    }

    private static Set<Integer> getNonCoveredLines(List<String> gcov_lines) {
	Set<Integer> lset = new HashSet<Integer>();
	for (String gcov_line : gcov_lines) {
	    gcov_line = gcov_line.trim();
	    if (gcov_line.startsWith("lcount:") &&
		gcov_line.endsWith(",0")) {
		String lno = gcov_line.substring(gcov_line.indexOf(":")+1, gcov_line.indexOf(","));
		lset.add(Integer.parseInt(lno));
	    }
	}
	return lset;
    }

    private static String getSemiColonAugmentedLabelLine(String oldline) {
	int ci0 = oldline.indexOf("//");
	int ci1 = oldline.indexOf("/*");
	int ci = -1;
	String newline = null;
	if (ci0 != -1 && ci1 == -1) { ci = ci0; }
	else if (ci0 == -1 && ci1 != -1) { ci = ci1; }
	else if (ci0 != -1 && ci1 != -1) { ci = (ci0 < ci1) ? ci0 : ci1; }
	if (ci != -1) {
	    newline = oldline.substring(0, ci) + ";" + oldline.substring(ci);
	}
	else {
	    newline = oldline + ";";
	}
	return newline;
    }
}
