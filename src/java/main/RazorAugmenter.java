package edu.gatech.cc.debaug;

import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import java.io.File;
import org.apache.commons.io.FileUtils;

public class RazorAugmenter
{
    public static void main(String[] args) {
	File gcov_af = new File(args[0]); //File generated by gcov with -a option. (This is a one-for-all file, as we only need to know what lines are included in what blocks.)
	File gcov_if = new File(args[1]); //File generated by gcov with -i option.
	File linef = new File(args[2]); //Line file marking the start and end of statements.
	File codef = new File(args[3]);
	File cgf = new File(args[4]); //.dot call graph file generated by clang --emit-llvm ...
	String augtype = args[5]; //zcall or zlib

	Map<Integer, Integer> sfs_map = LineFileParser.getStartEndLineMap(linef, "statement");
	Map<Integer, String> spfs_map = LineFileParser.getStartPropertyLineMap(linef, "statement");
	
	List<String> codeflines = null;
	try { codeflines = FileUtils.readLines(codef, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
        if (codeflines == null) { return; }

	List<String> gcov_iflines = null;
	try { gcov_iflines = FileUtils.readLines(gcov_if, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
	if (gcov_iflines == null) { return; }
	

	//Get basic blocks and a map that maps each basic block to the code it contains
	List<LineRange> bbs = getBBs(gcov_af);
	List<LineRange> fbcs = getFbCompounds(sfs_map, spfs_map);
	Map<LineRange, String> bb2codemap = getBB2CodeMap(bbs, fbcs, codeflines);
	/*
	for (LineRange lr : bb2codemap.keySet()) {
	    System.out.println("***** BB: " + lr);
	    System.out.println(bb2codemap.get(lr));
	}
	*/

	//*** Produce forbit functions ***
	Set<String> forbid_funcs = new HashSet<String>();
	Set<String> all_funcs = new HashSet<String>();
	Map<String,String> nid2funcmap = FunctionCallRelationGenerator.getNodeIdFuncNameMap(cgf);
	for (String func : nid2funcmap.values()) {
	    all_funcs.add(func);
	}
	
	if ("zcall".equals(augtype)) {
	    forbid_funcs = all_funcs;
	}
	else if ("zlib".equals(augtype)) {
	    Set<String> self_defined_funcs = LineFileParser.getFunctionNameStartEndLineMap(linef).keySet();
	    String covcodenospace = getCovCodeWithinFuncs(gcov_iflines, codeflines, fbcs).replaceAll("\\s+", ""); //A string containing all the covered statements
	    for (String func : all_funcs) {
		if (!self_defined_funcs.contains(func)) { //External func
		    if (!covcodenospace.contains(func+"(")) { //Not covered
			forbid_funcs.add(func);
		    }
		}
	    }
	}
	else {
	    System.out.println("Unknown augtype: " + augtype);
	    return;
	}


	//PRINT
	/*
	for (String func : all_funcs) {
	    System.out.print(func + " ");
	}
	System.out.println();
	System.out.println();
	for (String func : covered_funcs) {
	    System.out.print(func + " ");
	}
	System.out.println();
	*/


	//*** Augmentation ***
	//Build a list of lcovs and a map
	List<LineCover> lcovs = new ArrayList<LineCover>();
	Map<Integer,Integer> ln2idxmap = new HashMap<Integer,Integer>();
	int curr_idx = 0;
	for (String gcov_ifline : gcov_iflines) {
	    gcov_ifline = gcov_ifline.trim();
	    if (gcov_ifline.startsWith("lcount:")) {
		String lncover = gcov_ifline.substring(gcov_ifline.indexOf(":")+1);
		int ln = Integer.parseInt(lncover.split(",")[0]);
		int cover = Integer.parseInt(lncover.split(",")[1]);
		
		lcovs.add(new LineCover(ln, cover));
		ln2idxmap.put(ln, curr_idx);
		curr_idx += 1;
	    }
	}

	//Iterate BB. For any target, update its line coverage in lcovs.
	int bbs_total = bbs.size();
	int bbs_toaug = 0;
	for (LineRange bb : bbs) {
	    String bbcode = bb2codemap.get(bb);
	    //============
	    //System.err.println("BB ("+bb.getStartLine()+","+bb.getEndLine()+") Code:\n" + bbcode);
	    //============	    
	    boolean bb_toaug = true;
	    for (String forbid_func : forbid_funcs) {
		if (bbcode.contains(forbid_func+"(")) {
		    bb_toaug = false;
		    break;
		}
	    }
	    //============
	    //System.err.println("BB Aug: " + bb_toaug);
	    //============	    
	    
	    if (bb_toaug) {
		bbs_toaug += 1;
		for (int l=bb.getStartLine(); l<=bb.getEndLine(); l++) {
		    //Look for lines as (the start of) statements
		    //=============
		    //System.err.println("Start line: " + l);
		    //=============		    
		    if (sfs_map.get(l) != null) {
			int el = sfs_map.get(l).intValue();
			String prop = spfs_map.get(l);

			//Add this line
			Integer lidxitem = ln2idxmap.get(l);
			if (lidxitem != null) { //Wierd if null
			    LineCover lc = lcovs.get(lidxitem.intValue());
			    lc.setCover(1); //Make it covered
			    //=============
			    //System.err.println("Added this line: " + lc.getLineNumber());
			    //=============
			}

			//Add additional lines (in certain cases)
			if ("compound".equals(prop)) {
			    //Make the ending line covered (might have missing "}" otherwise)
			    Integer elidxitem = ln2idxmap.get(el);
			    if (elidxitem != null) {
				LineCover lc = lcovs.get(elidxitem.intValue());
				lc.setCover(1); //Make it covered
				//=============
				//System.err.println("Added compound line: " + lc.getLineNumber());
				//=============
			    }
			}
			//Primitive statements may span across lines
			else if ("null".equals(prop) || "return".equals(prop) ||
				 "decl".equals(prop) || "other".equals(prop)) {
			    //Make all the lines covered by the statement covered
			    for (int k=l+1; k<=el; k++) {
				Integer kidxitem = ln2idxmap.get(k);
				if (kidxitem != null) {
				    LineCover lc = lcovs.get(kidxitem.intValue());
				    lc.setCover(1); //Make it cover
				    //=============
				    //System.err.println("Added primitive line: " + lc.getLineNumber());
				    //=============
				}
			    }
			}
		    }
		}
	    }
	}

	//Make all decl stmts covered
	for (Integer lnitem : spfs_map.keySet()) {
	    if ("decl".equals(spfs_map.get(lnitem))) {
		int sl = lnitem.intValue();
		int el = sfs_map.get(sl).intValue();
		for (int k=sl; k<=el; k++) {
		    Integer kidxitem = ln2idxmap.get(k);
		    if (kidxitem != null) {
			LineCover lc = lcovs.get(kidxitem.intValue());
			lc.setCover(1);
		    }
		}
	    }
	}
	
	//Create a line-count map for code removal
	Map<Integer,Long> lcmap = new HashMap<Integer,Long>();
	for (LineCover lc : lcovs) {
	    //============
	    //System.err.println(lc.getLineNumber() + ", " + lc.getCover());
	    //============
	    lcmap.put(lc.getLineNumber(), (long) lc.getCover());
	}

	//==============
	//Print counts of bbs
	System.err.println(bbs_total + ", " +bbs_toaug);
	//==============	
	
	//Remove code based on new coverage
	String rslt_code = GCovBasedCodeRemover.getRemovedString(codef, linef, lcmap);
	System.out.println(rslt_code);
    }

    private static String getCovCodeWithinFuncs(List<String> gcov_iflines, List<String> codeflines, List<LineRange> fbcs) {
	String covcode = "";
	StringBuilder covcodesb = null;
	for (String gcov_ifline : gcov_iflines) {
	    gcov_ifline = gcov_ifline.trim();
	    if (gcov_ifline.startsWith("lcount:") && !gcov_ifline.endsWith(",0")) {
		int ln = Integer.parseInt(gcov_ifline.substring(gcov_ifline.indexOf(":")+1, gcov_ifline.indexOf(",")));

		boolean within_fb = false;
		for (LineRange lr : fbcs) {
		    if (lr.getStartLine() < ln && ln < lr.getEndLine()) {
			within_fb = true;
			break;
		    }
		}

		if (within_fb) {
		    if (covcodesb == null) { covcodesb = new StringBuilder(); }
		    else { covcodesb.append("\n"); }
		    covcodesb.append(codeflines.get(ln - 1));
		}
	    }
	}

	if (covcodesb != null) {
	    covcode = covcodesb.toString();
	}
	return covcode;
    }
    
    private static Map<LineRange, String> getBB2CodeMap(List<LineRange> bbs, List<LineRange> fbcs, List<String> codeflines) {
	Map<LineRange,String> bb2code = new HashMap<LineRange,String>();
	for (LineRange bb : bbs) {
	    int bb_sl = bb.getStartLine();
	    int bb_el = bb.getEndLine();
	    StringBuilder cls_sb = null; //String of code lines
	    for (LineRange fbc : fbcs) {
		if (fbc.getStartLine() >= bb_el || fbc.getEndLine() <= bb_sl) { //Non-overlapping
		    continue;
		}
		int fbc_sl = fbc.getStartLine();
		int fbc_el = fbc.getEndLine();
		int sl = (bb_sl >= fbc_sl+1) ? bb_sl : (fbc_sl+1);
		int el = (bb_el <= fbc_el-1) ? bb_el : (fbc_el-1);
		for (int i=sl-1; i<=el-1; i++) {
		    if (cls_sb == null) { cls_sb = new StringBuilder(); }
		    else { cls_sb.append("\n"); }
		    cls_sb.append(codeflines.get(i));
		}
	    }

	    //Print code
	    if (cls_sb != null) {
		bb2code.put(bb, cls_sb.toString().trim().replaceAll("\\s+", ""));
	    }
	    else {
		bb2code.put(bb, "");
	    }
	}
	return bb2code;
    }

    private static List<LineRange> getFbCompounds(Map<Integer, Integer> sfs_map, Map<Integer, String> spfs_map) {
	List<LineRange> rslt_list = new ArrayList<LineRange>();
	for (Integer slitem : spfs_map.keySet()) {
	    if ("fbcompound".equals(spfs_map.get(slitem))) {
		rslt_list.add(new LineRange(slitem.intValue(), sfs_map.get(slitem).intValue()));
	    }
	}
	return rslt_list;
    }
    
    private static List<LineRange> getBBs(File gcov_af) {
	List<String> gcov_aflines = null;
	try { gcov_aflines = FileUtils.readLines(gcov_af, (String) null); }
	catch (Throwable t) { System.err.println(t); t.printStackTrace(); }
	if (gcov_aflines == null) { return null; }

	List<LineRange> bbs = new ArrayList<LineRange>();
	String bb_delim_ptn = ".*:\\s+\\d+-block\\s+0";
	int sl = 1;
	for (String gcov_afline : gcov_aflines) {
	    if (!gcov_afline.matches(bb_delim_ptn)) { continue; }
	    int el = Integer.parseInt(gcov_afline.substring(gcov_afline.indexOf(":")+1, gcov_afline.indexOf("-")).trim());
	    bbs.add(new LineRange(sl, el));
	    sl = el + 1;
	}

	//Add the very last block
	String cl_ptn = ".*:\\s+\\d+:.*";
	int last_el = -1;
	for (int i=gcov_aflines.size()-1; i>=0; i--) {
	    String gcov_afline = gcov_aflines.get(i);
	    if (gcov_afline.matches(cl_ptn)) {
		int i0 = gcov_afline.indexOf(":");
		int i1 = gcov_afline.indexOf(":", i0+1);
		last_el = Integer.parseInt(gcov_afline.substring(i0+1, i1).trim());
		break;
	    }
	}
	bbs.add(new LineRange(sl, last_el));
	return bbs;
    }

    private static class LineRange {
	int sl, el;
	public LineRange(int sl_, int el_) {
	    sl = sl_;
	    el = el_;
	}
	public int getStartLine() { return sl; }
	public int getEndLine() { return el; }
	public String toString() { return sl + "," + el; }
    }

    private static class LineCover {
	int ln, cover;
	public LineCover(int ln_, int cover_) {
	    ln = ln_;
	    cover = cover_;
	}
	public int getLineNumber() { return ln; }
	public int getCover() { return cover; }
	public String toString() { return ln + "," + cover; }
	public void setCover(int c) { cover = c; }
    }
}
